directive scala
/*
 * Prelude for Soda types in Scala.
 */
type Nat = Int
object Nat {
  object Succ_ {
    def unapply (n : Int) : Option [Int] = if (n <= 0) None else Some (n - 1)
  }
}

directive lean
/-
 - Prelude for Soda types in Lean.
 -/
notation "Nat.Succ_" => Nat.succ


class Index = Nat

class Money = Int


class Item

  abstract
    owner : Index
    price : Money
    advertised : Boolean

end


class Market

  abstract
    accounts : List [Money]
    items : List [Item]

end


class MyList

  abstract
    bit : Boolean

/*
 * foldl
 * (fold left)
 */

  _tailrec_foldl [A : Type] [B : Type] (sequence : List [A] ) (current : B)
      (next_value : B -> A -> B) : B =
    match sequence
      case Nil ==> current
      case (head) :: (tail) ==>
        _tailrec_foldl [A] [B] (tail) (next_value (current) (head) ) (next_value)

  foldl [A : Type] [B : Type] (sequence : List [A] ) (initial_value : B)
      (next_value : B -> A -> B) : B =
    _tailrec_foldl [A] [B] (sequence) (initial_value) (next_value)

/*
 * length
 */

  length_fl [A : Type] (list : List [A] ) : Index =
    foldl [A] [Index] (list) (0) (
      lambda (accum : Index) -->
        lambda (elem : A) --> accum + 1
    )

  directive lean
  theorem
    len_fl_accum (A : Type) (list : List (A) )
       : forall (accum : Index) ,
        _tailrec_foldl (A) (Index) (list) (accum) (fun (accum : Index) => fun (elem : A) => accum + 1) =
           _tailrec_foldl (A) (Index) (list) (0) (fun (accum : Index) => fun (elem : A) => accum + 1) + accum := by
      induction list with
      | nil =>
        intro n
        rewrite [_tailrec_foldl, _tailrec_foldl, Nat.zero_add]
        rfl
      | cons head tail ih =>
        intro n
        rewrite [_tailrec_foldl, _tailrec_foldl]
        rewrite [ih (1)]
        rewrite [ih (n + 1)]
        rewrite [Nat.add_assoc]
        rewrite [Nat.add_comm 1]
        rfl

  _tailrec_length [A : Type] (list : List [A] ) (accum : Index) : Index =
    match list
      case Nil ==> accum
      case (head) :: (tail) ==>
        _tailrec_length [A] (tail) (accum + 1)

  directive lean
  theorem
    len_tr_accum (A : Type) (list : List (A) )
      : forall (accum : Index) ,
        _tailrec_length (A) (list) (accum)  = _tailrec_length (A) (list) (0) + accum := by
      induction list with
      | nil =>
        intro n
        rewrite [_tailrec_length, _tailrec_length, Nat.zero_add]
        rfl
      | cons head tail ih =>
        intro n
        rewrite [_tailrec_length, _tailrec_length]
        rewrite [ih (1)]
        rewrite [ih (n + 1)]
        rewrite [Nat.add_assoc]
        rewrite [Nat.add_comm 1]
        rfl

  length_tr [A : Type] (list : List [A] ) : Index =
    _tailrec_length [A] (list) (0)

  length_def [A : Type] (list : List [A] ) : Index =
    match list
      case Nil ==> 0
      case (head) :: (tail) ==> length_def [A] (tail) + 1

  directive lean
  theorem
  len_fl_eq_len_def (A : Type) (list : List (A))
      : length_fl (A) (list) = length_def (A) (list) := by
    rewrite [length_fl, foldl]
    induction list with
    | nil =>
      rewrite [_tailrec_foldl, length_def]
      rfl
    | cons head tail ih =>
      rewrite [_tailrec_foldl, len_fl_accum]
      rewrite [ih]
      rewrite [length_def]
      rfl

  directive lean
  theorem
    len_tr_eq_len_def
      : length_tr = length_def := by
    funext A list
    rewrite [length_tr]
    induction list with
    | nil =>
      rewrite [_tailrec_length, length_def]
      rfl
    | cons head tail ih =>
      rewrite [_tailrec_length, len_tr_accum]
      rewrite [ih]
      rewrite [length_def]
      rfl

  length [A : Type] (list : List [A] ) : Index =
    length_fl [A] (list)

/*
 * reverse
 */

  _tailrec_reverse [A : Type] (list : List [A] ) (accum : List [A] ) : List [A] =
    match list
      case Nil ==> accum
      case (head) :: (tail) ==> _tailrec_reverse [A] (tail) ( (head) :: (accum) )

  reverse_tr [A : Type] (list : List [A] ) : List [A] =
    _tailrec_reverse [A] (list) (Nil)


  reverse_fl [A : Type] (list : List [A] ) : List [A] =
    foldl [A] [List [A] ] (list) (Nil) (
      lambda (accum : List [A] ) -->
        lambda (elem : A) -->
          (elem) :: (accum)
    )

  directive lean
  theorem
    rev_fl_accum (A : Type) (list : List (A))
      : forall (current: List (A) ),
        _tailrec_foldl (A) (List (A) ) (list) (current)
          (fun (accum : List (A) ) =>
            fun (elem : A) =>
               (elem) :: (accum)
          ) = _tailrec_reverse (A) (list) (current) := by
      induction list with
      | nil =>
        intro other
        rewrite [_tailrec_foldl, _tailrec_reverse]
        rfl
      | cons head tail ih =>
        intro other
        rewrite [_tailrec_foldl, _tailrec_reverse]
        rewrite [ih ((head) :: (other))]
        rfl

  directive lean
  theorem
    rev_tr_eq_rev_fl
      (A : Type) (list : List (A) )
        : reverse_fl (A) (list) = reverse_tr (A) (list) := by
    rewrite [reverse_fl, reverse_tr, foldl, rev_fl_accum]
    rfl

  directive lean
  theorem
    len_rev_accum (A : Type) (list : List (A))
      : forall (accum : List (A) ),
        length_def (A) (_tailrec_reverse (A) (list) (accum)) =
            length_def (A) (_tailrec_reverse (A) (list) ([])) + length_def (A) (accum) := by
      induction list with
      | nil =>
        intro other
        rewrite [_tailrec_reverse, _tailrec_reverse, length_def, Nat.zero_add]
        rfl
      | cons head tail ih =>
        intro other
        rewrite [_tailrec_reverse, _tailrec_reverse]
        rewrite [ih ((head) :: ([]))]
        rewrite [ih ((head) :: (other))]
        rewrite [length_def, length_def, length_def]
        rewrite [Nat.add_assoc, Nat.add_comm 1]
        rfl

  directive lean
  theorem
    rev_rev (A : Type) (list : List (A) )
      : reverse_tr (A) (reverse_tr (A) (list) ) = list := by
    rewrite [reverse_tr, reverse_tr]
    induction list with
    | nil =>
      rewrite [_tailrec_reverse, _tailrec_reverse]
      rfl
    | cons head tail ih =>
      rewrite [_tailrec_reverse]
      induction tail with
      | nil =>
        rewrite [_tailrec_reverse, _tailrec_reverse, _tailrec_reverse]
        rfl
      | cons hd tl ih2 =>
        sorry

  reverse [A : Type] (list : List [A] ) : List [A] =
    reverse_fl [A] (list)

/*
 * map
 */

  _tailrec_map_rev [A : Type] [B : Type] (list : List [A] ) (func : A -> B) (accum : List [B] )
      : List [B] =
    match list
      case Nil ==> accum
      case (head) :: (tail) ==>
          _tailrec_map_rev [A] [B] (tail) (func) ( (func (head) ) :: (accum) )

  map [A : Type] [B : Type] (list : List [A] ) (func : A -> B) : List [B] =
    reverse_tr [B] (_tailrec_map_rev [A] [B] (list) (func) (Nil) )

  map_def [A : Type] [B : Type] (list : List [A] ) (func : A -> B ) : List [B] =
    match list
      case Nil ==> Nil
      case (head) :: (tail) ==> (func (head) ) :: (map_def [A] [B] (tail) (func) )

  directive lean
  theorem
    map_eq_map_def (A : Type) (B : Type) (list : List (A)) (func : A -> B)
      : map (A) (B) (list) (func) = map_def (A) (B) (list) (func) := by
    rewrite [map, reverse_tr]
    induction list with
    | nil =>
      rewrite [map_def, _tailrec_map_rev, _tailrec_reverse]
      rfl
    | cons head tail ih =>
      rewrite [map_def, _tailrec_map_rev]
      sorry

  directive lean
  theorem
    len_map (A : Type) (B : Type) (list : List (A) ) (func : A -> B)
      : length_tr (B) (map (A) (B) (list) (func) ) = length_tr (A) (list) := by
      rewrite [map_eq_map_def, len_tr_eq_len_def]
      induction list with
      | nil =>
        rewrite [map_def, length_def, length_def]
        rfl
      | cons head tail ih =>
        rewrite [map_def, length_def, length_def]
        rewrite [ih]
        rfl

/*
 * concat
 */

  _tailrec_concat [A : Type] (rev_first : List [A] ) (second : List [A] ) : List [A] =
    match rev_first
      case Nil ==> second
      case (head) :: (tail) ==> _tailrec_concat [A] (tail) ( (head) :: (second) )

  concat [A : Type] (first : List [A] ) (second : List [A] ) : List [A] =
    _tailrec_concat [A] (reverse [A] (first) ) (second)

  monus1 (index : Index) : Index =
    match index
      case 0 ==> 0
      case Nat.Succ_ (k) ==> k

  directive lean
  theorem
    monus1_succ
      : forall (index : Index),
        monus1 (Nat.succ (index)) = index := by
    intro idx
    rewrite [monus1]
    simp

  _tailrec_get [A : Type] (list : List [A] ) (index : Index) : Option [A] =
    match list
      case Nil ==> None
      case (head) :: (tail) ==>
        if index == 0
        then Some (head)
        else _tailrec_get [A] (tail) (monus1 (index) )

  get [A : Type] (list : List [A] ) (index : Index) : Option [A] =
    _tailrec_get [A] (list) (index)

  _tailrec_set [A : Type] (list : List [A] ) (accum : List [A] ) (index : Index)
      (element : A) : List [A] =
    match list
      case Nil ==> reverse [A] (accum)
      case (head) :: (tail) ==>
        if index == 0
        then concat [A] (reverse [A] (accum) ) ( (element) :: (tail) )
        else _tailrec_set [A] (tail) ( (head) :: (accum) ) (monus1 (index) ) (element)

  set_tr [A : Type] (list : List [A] ) (index : Index) (element : A) : List [A] =
    _tailrec_set [A] (list) (Nil) (index) (element)

  set_def [A : Type] (list : List [A] ) (index : Index) (element : A) : List [A] =
    match list
      case Nil ==> Nil
      case (head) :: (tail) ==>
        if index == 0
        then (element) :: (tail)
        else (element) :: (set_def [A] (tail) (monus1 (index) ) (element) )

  directive lean
  theorem
    len_set (A : Type) (list : List (A)) (element : A)
      : forall (index : Index),
        length_def (A) (set_def (A) (list) (index) (element) ) = length_def (A) (list) := by
    induction list with
    | nil =>
      intro idx
      rewrite [set_def, length_def]
      rfl
    | cons head tail ih =>
       intro idx
       rewrite [set_def, length_def]
       cases idx with
       | zero =>
         rewrite [monus1]
         rewrite [Nat.zero_eq]
         rfl
       | succ k =>
         rewrite [monus1]
         simp
         rewrite [length_def]
         rewrite [ih]
         rfl


  directive lean
  theorem
    set_tr_eq_set_def (A : Type) (list : List (A)) (index : Index) (element : A)
      : set_tr (A) (list) (index) (element) = set_def (A) (list) (index) (element) := by
    rewrite [set_tr]
    induction list with
    | nil =>
      rewrite [_tailrec_set, reverse, rev_tr_eq_rev_fl, reverse_tr, _tailrec_reverse, set_def]
      rfl
    | cons head tail ih =>
      rewrite [_tailrec_set, reverse, rev_tr_eq_rev_fl, reverse_tr, _tailrec_reverse, set_def]
      cases index with
      | zero =>
        rewrite [concat, reverse, rev_tr_eq_rev_fl, reverse_tr, _tailrec_reverse, _tailrec_concat]
        rfl
      | succ idx =>
        rewrite [concat, reverse, rev_tr_eq_rev_fl, reverse_tr, _tailrec_reverse, _tailrec_concat]
        rewrite [monus1_succ]
        sorry


  set [A : Type] (list : List [A] ) (index : Index) (element : A) : List [A] =
    set_tr [A] (list) (index) (element)

end

class MarketMod

  abstract
    bit : Boolean

  _mm : MyList = MyList_ (true)

  directive lean
  notation "_mm.get" => MyList.get
  notation "_mm.set" => MyList.set
  notation "_mm.foldl" => MyList.foldl

  as_market (market : Market) : Market =
    Market.mk (market .accounts) (market .items)

  get_items (market : Market) : List [Item] =
    match market
      case Market_ (accounts) (items) ==> items

  directive lean
  theorem
    proj_items (market : Market) (accounts : List (Money)) (items : List (Item))
      : (market = Market_ (accounts) (items) ) -> get_items (market) = items := by
    rewrite [get_items]
    cases market
    intro h1
    rewrite [h1]
    simp


  _advertise (items : List [Item] ) (item_id : Index) : List [Item] =
    match (_mm .get [Item] (items) (item_id) )
      case Some (item) ==>
        _mm .set [Item] (items) (item_id) (Item_ (item .owner) (item .price) (true) )
      case otherwise ==> items

  advertise (market : Market) (item_id : Index) : Market =
    Market.mk (market .accounts) (_advertise (market .items) (item_id) )

  _remove_ad (items : List [Item] ) (item_id : Index) : List [Item] =
    match (_mm .get [Item] (items) (item_id) )
      case Some (item) ==>
        _mm .set [Item] (items) (item_id) (Item_ (item .owner) (item .price) (false) )
      case otherwise ==> items

  remove_ad (market : Market) (item_id : Index) : Market =
    Market.mk (market .accounts) (_remove_ad (market .items) (item_id) )

  _transfer_with_balances (accounts : List [Money] ) (origin : Index) (target : Index)
      (amount : Money) (origin_balance : Money) (target_balance : Money) : List [Money] =
    _mm .set [Money] (_mm .set [Money] (accounts)
      (origin) (origin_balance - amount) ) (target) (target_balance + amount)

  _transfer_with (accounts : List [Money] ) (origin : Index) (target : Index) (amount : Money)
      (origin_balance : Money) : List [Money] =
    match (_mm .get [Money] (accounts) (target) )
      case Some (target_balance) ==>
        _transfer_with_balances (accounts) (origin) (target)
          (amount) (origin_balance) (target_balance)
      case otherwise ==> accounts

  _transfer (accounts : List [Money] ) (origin : Index) (target : Index) (amount : Money)
      : List [Money] =
    match (_mm .get [Money] (accounts) (origin) )
      case Some (origin_balance) ==>
        _transfer_with (accounts) (origin) (target) (amount) (origin_balance)
      case None ==> accounts

  sell (market : Market) (item_id : Index) (buyer : Index) : Market =
    match (_mm .get [Item] (market .items) (item_id) )
      case Some (item) ==>
        Market.mk (
          _transfer (market .accounts) (buyer) (item .owner) (item .price) ) (
          _mm .set [Item] (market .items) (item_id) (Item_ (buyer) (item .price) (false) )
        )
      case otherwise ==>
        market

  _sum_pair (a : Money) (b : Money) : Money =
    a + b

  assets (market : Market) : Money =
    _mm .foldl [Money] [Money] (market .accounts) (0) (_sum_pair)

  directive lean
  theorem
    conservation_of_items_after_sell_operation (market : Market) (item_id : Index) (buyer : Index) :
      MyList.length_def (Item) (get_items ( (sell (market) (item_id) (buyer) ) ) ) =
        MyList.length_def (Item) (get_items (market) ) := by
    sorry

  directive lean
  theorem
    lemma_foldl (accounts : List (Money) ) (items : List (Item) ) (item_id : Index) (buyer :
    Index) :
     MyList.foldl (Money) (Money) ( (sell (Market_ (accounts) (items)) (item_id) (buyer) ).accounts)
     (0) (_sum_pair) =
       MyList.foldl (Money) (Money) (accounts) (0) (_sum_pair) := by
         sorry

  directive lean
  theorem
    conservation_of_money_after_sell_operation (market : Market) (item_id : Index) (buyer : Index) :
      assets (sell (market) (item_id) (buyer) ) = assets (market) :=
    lemma_foldl (market.accounts) (market.items) (item_id) (buyer)

end

