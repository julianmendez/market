
directive lean
notation:max "Boolean" => Bool
notation:max "Some" => some

directive scala
type Nat = Int

class Index = Nat

class Money = Int


class Item

  abstract
    owner : Index
    price : Money
    advertised : Boolean

end


class Market

  abstract
    accounts : List [Money]
    items : List [Item]

end


class MarketMod

  directive scala
  def get [A] (list : List [A]) (index : Index) : Option [A] =
    list.lift (index)

  directive lean
  def get {A : Type} (list : List (A)) (index : Index) : Option (A) :=
    list.get? (index)

  directive scala
  def set [A] (list : List [A]) (index : Index) (element : A) : List [A] =
    if (index < list.length)
    then list.updated (index , element)
    else list

  directive lean
  def set {A : Type} (list : List (A)) (index : Index) (element : A) : List (A) :=
    if (index < list.length)
    then list.set (index) (element)
    else list

  mk_market (new_accounts : List [Money] ) (new_items : List [Item] ) : Market =
    Market_ (new_accounts) (new_items)

  as_market (market : Market) : Market =
    mk_market (market .accounts) (market .items)

  _advertise_item (item : Item) : Item =
    Item_ (item .owner) (item .price) (true)

  _advertise (items : List [Item] ) (item_id : Index) : List [Item] =
    match (get (items) (item_id) )
      case Some (item) ==> set (items) (item_id) (_advertise_item (item) )
      case otherwise ==> items

  advertise (market : Market) (item_id : Index) : Market =
    mk_market (market .accounts) (_advertise (market .items) (item_id) )

  _hide_item (item : Item) : Item =
    Item_ (item .owner) (item .price) (false)

  _remove_ad (items : List [Item] ) (item_id : Index) : List [Item] =
    match (get (items) (item_id) )
      case Some (item) ==> set (items) (item_id) (_hide_item (item) )
      case otherwise ==> items

  remove_ad (market : Market) (item_id : Index) : Market =
    mk_market (market .accounts) (_remove_ad (market .items) (item_id) )

  _transfer_with_balances (accounts : List [Money] ) (origin : Index) (target : Index)
      (amount : Money) (origin_balance : Money) (target_balance : Money) : List [Money] =
    set (set (accounts) (origin) (origin_balance - amount) ) (target) (target_balance + amount)

  _transfer_with (accounts : List [Money] ) (origin : Index) (target : Index) (amount : Money)
      (origin_balance : Money) : List [Money] =
    match (get (accounts) (target) )
      case Some (target_balance) ==>
        _transfer_with_balances (accounts) (origin) (target) (amount) (origin_balance) (target_balance)
      case otherwise ==> accounts

  _transfer (accounts : List [Money] ) (origin : Index) (target : Index) (amount : Money)
      : List [Money] =
    match (get (accounts) (origin) )
      case Some (origin_balance) ==>
        _transfer_with (accounts) (origin) (target) (amount) (origin_balance)
      case None ==> accounts

  _give (items : List [Item] ) (item_id : Index) (buyer : Index) (price : Money) : List [Item] =
    set (items) (item_id) (Item_ (buyer) (price) (false) )

  _sell_item (market : Market) (item : Item) (item_id : Index) (buyer : Index) : Market =
    mk_market (
      _transfer (market .accounts) (buyer) (item .owner) (item .price) ) (
      _give (market .items) (item_id) (buyer) (item .price)
    )

  sell (market : Market) (item_id : Index) (buyer : Index) : Market =
    match (get (market .items) (item_id) )
      case Some (item) ==>
        _sell_item (market) (item) (item_id) (buyer)
      case otherwise ==>
        market

end

