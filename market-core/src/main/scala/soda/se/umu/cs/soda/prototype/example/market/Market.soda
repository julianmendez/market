
directive lean
/- Prelude for Soda types. -/
notation:max "Boolean" => Bool
notation:max "None" => none
notation:max "Some" => some
notation:max "Nil" => []

directive scala
type Nat = Int

class Index = Nat

class Money = Int


class Item

  abstract
    owner : Index
    price : Money
    advertised : Boolean

end


class Market

  abstract
    accounts : List [Money]
    items : List [Item]

end


class MarketMod

  abstract

  _tailrec_fold [A : Type] [B : Type] (sequence : List [A] ) (current : B)
      (next_value : B -> A -> B) : B =
    match sequence
      case Nil ==> current
      case (head) :: (tail) ==>
        _tailrec_fold [A] [B] (tail) (next_value (current) (head) ) (next_value)

  fold [A : Type] [B : Type] (sequence : List [A] ) (initial_value : B)
      (next_value : B -> A -> B) : B =
    _tailrec_fold [A] [B] (sequence) (initial_value) (next_value)

  _tailrec_length [A : Type] (list : List [A] ) (accum : Index) : Index =
    match list
      case Nil ==> accum
      case (head) :: (tail) ==>
        _tailrec_length [A] (tail) (accum + 1)

  length [A : Type] (list : List [A] ) : Index =
    _tailrec_length [A] (list) (0)

  _tailrec_reverse [A : Type] (list : List [A] ) (accum : List [A] ) : List [A] =
    match list
      case Nil ==> accum
      case (head) :: (tail) ==> _tailrec_reverse [A] (tail) ( (head) :: (accum) )

  reverse [A : Type] (list : List [A] ) : List [A] =
    _tailrec_reverse [A] (list) (Nil)

  directive lean
  theorem
    add_succ (n : Index) (m : Index)
      : (n = m) -> (n + 1 = m + 1) := by
        intro h
        rewrite [h]
        rfl

  directive lean
  theorem
    len_base (A : Type) (list : List (A)) (accum : Index)
      : _tailrec_length (A) (list) (accum + 1) = (_tailrec_length (A) (list) (accum)) + 1 := by
       sorry

  directive lean
  theorem
    len_rev_base_nil (A : Type) (head : A) (tail : List (A))
     : _tailrec_length (A) (_tailrec_reverse (A) (tail) ((head) :: ([])) ) (0) =
     _tailrec_length (A) ((head) :: _tailrec_reverse (A) (tail) ([]) ) (0) := by
       induction tail with
       | nil =>
         constructor
       | cons hd tl ih =>
         rewrite [_tailrec_reverse, _tailrec_reverse]
         sorry

  directive lean
  theorem
    len_rev (A : Type) (list : List (A) )
      : length (A) (reverse (A) (list)) = length (A) (list) := by
    induction list with
    | nil =>
        constructor
    | cons head tail h1 =>
        rewrite [length, length, reverse] at h1
        rewrite [length, length, reverse]
        rewrite [_tailrec_reverse]
        rewrite [len_rev_base_nil]
        rewrite [_tailrec_length, _tailrec_length]
        rewrite [len_base, len_base]
        apply add_succ
        exact h1

  _tailrec_concat [A : Type] (rev_first : List [A] ) (second : List [A] ) : List [A] =
    match rev_first
      case Nil ==> second
      case (head) :: (tail) ==> _tailrec_concat [A] (tail) ( (head) :: (second) )

  concat [A : Type] (first : List [A] ) (second : List [A] ) : List [A] =
    _tailrec_concat [A] (reverse [A] (first) ) (second)

  monus1 (index : Index) : Index =
    if index <= 0
    then 0
    else index - 1

  _tailrec_get [A : Type] (list : List [A] ) (index : Index) : Option [A] =
    match list
      case Nil ==> None
      case (head) :: (tail) ==>
        if index == 0
        then Some (head)
        else _tailrec_get [A] (tail) (monus1 (index) )

  get [A : Type] (list : List [A] ) (index : Index) : Option [A] =
    _tailrec_get [A] (list) (index)

  _tailrec_set [A : Type] (list : List [A] ) (accum : List [A] ) (index : Index)
      (element : A) : List [A] =
    match list
      case Nil ==> reverse [A] (accum)
      case (head) :: (tail) ==>
        if index == 0
        then concat [A] (reverse [A] (accum) ) ( (element) :: (tail) )
        else _tailrec_set [A] (tail) ( (head) :: (accum) ) (monus1 (index) ) (element)

  set [A : Type] (list : List [A] ) (index : Index) (element : A) : List [A] =
    _tailrec_set [A] (list) (Nil) (index) (element)


  mk_Market (new_accounts : List [Money] ) (new_items : List [Item] ) : Market =
    Market_ (new_accounts) (new_items)

  as_market (market : Market) : Market =
    mk_Market (market .accounts) (market .items)

  _advertise (items : List [Item] ) (item_id : Index) : List [Item] =
    match (get [Item] (items) (item_id) )
      case Some (item) ==>
        set [Item] (items) (item_id) (Item_ (item .owner) (item .price) (true) )
      case otherwise ==> items

  advertise (market : Market) (item_id : Index) : Market =
    mk_Market (market .accounts) (_advertise (market .items) (item_id) )

  _remove_ad (items : List [Item] ) (item_id : Index) : List [Item] =
    match (get [Item] (items) (item_id) )
      case Some (item) ==>
        set [Item] (items) (item_id) (Item_ (item .owner) (item .price) (false) )
      case otherwise ==> items

  remove_ad (market : Market) (item_id : Index) : Market =
    mk_Market (market .accounts) (_remove_ad (market .items) (item_id) )

  _transfer_with_balances (accounts : List [Money] ) (origin : Index) (target : Index)
      (amount : Money) (origin_balance : Money) (target_balance : Money) : List [Money] =
    set [Money] (set [Money] (accounts)
      (origin) (origin_balance - amount) ) (target) (target_balance + amount)

  _transfer_with (accounts : List [Money] ) (origin : Index) (target : Index) (amount : Money)
      (origin_balance : Money) : List [Money] =
    match (get [Money] (accounts) (target) )
      case Some (target_balance) ==>
        _transfer_with_balances (accounts) (origin) (target)
          (amount) (origin_balance) (target_balance)
      case otherwise ==> accounts

  _transfer (accounts : List [Money] ) (origin : Index) (target : Index) (amount : Money)
      : List [Money] =
    match (get [Money] (accounts) (origin) )
      case Some (origin_balance) ==>
        _transfer_with (accounts) (origin) (target) (amount) (origin_balance)
      case None ==> accounts

  sell (market : Market) (item_id : Index) (buyer : Index) : Market =
    match (get [Item] (market .items) (item_id) )
      case Some (item) ==>
        mk_Market (
          _transfer (market .accounts) (buyer) (item .owner) (item .price) ) (
          set [Item] (market .items) (item_id) (Item_ (buyer) (item .price) (false) )
        )
      case otherwise ==>
        market

  _sum_pair (a : Money) (b : Money) : Money =
    a + b

  assets (market : Market) : Money =
    fold [Money] [Money] (market .accounts) (0) (_sum_pair)

  directive lean
  theorem
    lemma_set_keeps_length_1 (A : Type) (index : Index) (element : A) :
      ((Nil).set (index) (element) ).length = 0 :=
      by constructor

  directive lean
  theorem
    lemma_set_keeps_length_2 (A : Type) (head : A) (tail : List (A) ) (element : A) :
      ((head :: tail).set (0) (head)).length = ((element :: tail).set (0) (element)).length :=
      by constructor

  directive lean
  theorem
    set_keeps_length (A : Type) (list : List (A)) (index : Index) (element : A) :
      (list.set (index) (element) ).length = list.length :=
    match list with
      | Nil => lemma_set_keeps_length_1 (A) (index) (element)
      | (head) :: (tail) =>
        match index with
          | 0 => lemma_set_keeps_length_2 (A) (head) (tail) (element)
          | k + 1 => sorry

  directive lean
  theorem
    conservation_of_items_after_sell_operation (market : Market) (item_id : Index) (buyer : Index) :
       (sell (market) (item_id) (buyer) ).items.length = market.items.length :=
    sorry

  directive lean
  theorem
    lemma_fold (accounts : List (Money) ) (items : List (Item) ) (item_id : Index) (buyer : Index) :
     fold (Money) (Money) ( (sell (Market_ (accounts) (items)) (item_id) (buyer) ).accounts) (0) (_sum_pair) =
       fold (Money) (Money) (accounts) (0) (_sum_pair) :=
         sorry

  directive lean
  theorem
    conservation_of_money_after_sell_operation (market : Market) (item_id : Index) (buyer : Index) :
      assets (sell (market) (item_id) (buyer) ) = assets (market) :=
    lemma_fold (market.accounts) (market.items) (item_id) (buyer)

end

